# 模板相关改动

## 一、右尖括号

在 C++98/03标准中

```c++
vector<list<int> > vec;  // 需要这样写
vector<list<int>> vec;  // error, >> 会被认为是右移操作符
```

在 C++11 标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出">>"是一个右移操作符还是模板参数表的结束标记。

```c++
template <typename T>
class Test {};

void func(void) {
    vector<Test<int>> vec;  // ok
}
```

## 二、模板别名

在 C++98/03 中，可以通过 typedef 来定义一个类型的别名，当然，并不是产生新的类型，而是一个别名而已。如：

```c++
typedef unsigned int uint;
```

因为是别名，所以并不能通过 typedef 来进行函数的重载：

```c++
typedef unsigned int uint;
void func(unsigned int);
void func(uint);    // error
```

C++11 中出现了可以重定义一个模板的语法：

```c++
template <typename T>
using str_map_t = map<string, T>;
str_map_t<int> map1;
```

这里使用了 C++11 的关键字 using，使用 macro 或 typedef 无法达到同样的效果：

```c++
#define Vec<T> template<typename T> vector<T, MyAlloc<T>>;

Vec<int> coll;
// 等同于
template<typename int> vector<int, MyAlloc<int>> coll;  // 并不是我们想要的结果

typedef vector<int, MyAlloc<int>> Vec;  // 类型固定成 int，typedef 不接受参数
```

using 几乎涵盖了 typedef 的所有功能。总的来说，typedef 有时候阅读难度比 using 更大（比如在定义函数指针的时候），using 别名语法比 typedef 更加清晰。

```c++
typedef unsigned int uint_t;
using uint_u = unsigned int;

typedef map<string, int> map_si_t;
using map_si_u = map<string, int>;

// 定义函数指针
typedef void (*func_t)(int, int);
using func_u = void(*)(int, int);

// C++98/03
template <typename T>
struct func_t {
    typedef void (*type)(T, T);
};
// 使用 func_t 模板
func_t<int>::type xx_1;
// C++11 
template <typename T>
using func_t = void(*)(T, T);
// 使用 func_t 模板
func_t<int> xx_2
```

```c++
// 测试使用移动语义的效率（想法）
void test_moveable(Container cntr, T elem) {
    Container<T> c;
    for (long i = 0; i < SIZE; ++i)
        c.insert(c.end(), T());
    output_static_data(T());
    Container<T> c1(c);
    Container<T> c2(std::move(c));
    c1.swap(c2);
}
test_moveable(list, MyString);
test_moveable(list, MyStrNoMove);
// 方法一
template<typename Container>
void test_moveable(Container c) {
    typedef typename iterator_traits<typename Container::iterator>::value_type Valtype;
    
    for (long i = 0; i < SIZE; ++i)
        c.insert(c.end(), Valtype());
    
    output_static_data(*(c.begin()));
    Container c1(c);
    Container c2(std::move(c));
    c1.swap(c2);
}

test_moveable(list<MyString>());
test_moveable(list<MyStrNoMove>());
test_moveable(vector<MyString>());
test_moveable(vector<MyStrNoMove>());
test_moveable(deque<MyString>());
test_moveable(deque<MyStrNoMove>());

// 方法二(模板模板参数)
typedef <typename T, template<class T> class Continer>
class XCls {
private:
    Container<T> c;
public:
    XCls() {
        for (long i = 0; i < SIZE; ++i)
            c.insert(c.end(), T());
        output_static_data(T());
        Container<T> c1(c);
        Container<T> c2(std::move(c));
        c1.swap(c2);
    }
};

XCls<MyString, vector> cl; // error: 当使用模板模板参数时，编译器无法推到 vector 的第二模板参数（vector有默认的第二模板参数）

template<typename T>
using Vec = vector<T, allocator<T>>;
template<typename T>
using Lst = list<T, allocator<T>>;
template<typename T>
using Deq = deque<T, allocator<T>>;

XCls<MyString, Vec> cl;
XCls<MyStrNoMove, Vec> c2;

XCls<MyString, Lst> c3;
XCls<MyStrNoMove, Lst> c4;

XCls<MyString, Deq> c5;
XCls<MyStrNoMove, Deq> c6;
```

`typedef <typename T, template<class T> class Continer>` 使用了模板模板参数。

