# 构造函数

### 一、explicit

explicit 专用于修饰构造函数，表示只能显式构造，不可以被隐式转换。

```c++
class TestA {
public:
    TestA(int value) {
        cout << "TestA(int)" << endl;
    }
};

class TestB {
public:
    explicit TestB(int value) {
        cout << "explicit TestB(int)" << endl;
    }
};

void main() {
    TestA ta = 1;  // 可以隐式转换
    
    TestB tb1 = 1;  // error，不可以隐式转换
    TestB tb2(2);  // ok
}
```

### 二、=default

C++11 引入 **default** 特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数。析构、拷贝构造、赋值操作符均可用。普通函数不可以用。

```c++
class Test {
    int a;
public:
    Test(int i) : a(i) {}
};

void main() {
    Test a;  // error
}
```

上面代码编译出错，因为没有匹配的构造函数，因为编译器没有生成默认构造函数，而只需在函数声明后加上“=default;”，会生成默认的构造函数，编译器将为显式声明为 default 函数自动生成函数体。

```c++
class Test {
    int a;
public:
    Test() = default;
    Test(int i) : a(i) {}
};

void main() {
    Test a;  // ok
}
```

### 三、=delete

C++ 中，如果没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符。delete 与 default 相反。

```c++
class Test {
    int a;
public:
    Test() = default;
    Test(int i) : a(i) {}
};

void main() {
    Test a1;
    Test a2 = a1;  // ok, 调用编译器隐式生成的默认拷贝构造函数
    Test a3;
    a3 = a1;  // ok, 调用编译器隐式生成的默认拷贝赋值操作符
}
```

而有时候想禁止对象的拷贝与赋值，可以使用 **delete** 修饰。也可以将拷贝和赋值的函数声明为 private。

```c++
class Test {
    int a;
public:
    Test() = default;
    Test(const A&) = delete;
    Test& operator=(const A&) = delete;
    Test(int i) : a(i) {}
};

void main() {
    Test a1;
    Test a2 = a1;  // error, 拷贝构造函数被禁用
    Test a3;
    a3 = a1;  // error, 拷贝赋值操作符被禁用
}
```

**delete** 在 C++11 中很常用，std::unique_ptr 就是通过 delete 修饰来禁止对象的拷贝的。

### 四、继承构造函数

如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。

```c++
class Base {
public:
    Base(int i) {}
    Base(double d, int i) {}
    Base(float f, int i, const char *c) {}
    // ...
};
class Derived : public Base {
    Derived(int i) : Base(i) {}
    Derived(double d, int i) : Base(d, i) {}
    Derived(float f, int i, const char *c) : Base(f, i, c) {}
    // ...
    virtual void ExtraInterface() {}
};
```

在 C++ 中，如果派生类要使用**基类的成员函数（非虚函数）**，可以通过 using 声明完成。

```c++
class Base {
    void f(double i) { cout << "Base:" << i << endl;}
};

class Derived : public Base {
    using Base::f;
    void f(int i) { cout << "Derived:" << i << endl; }
};

int main() {
    Base b;
    b.f(4.5);  // Base: 4.5
    Derived d;
    d.f(4.5);  // Base: 4.5
}
```

在 C++11 中，这个想法被扩展到了构造函数上，子类可以通过使用 using 声明来声明继承基类的构造函数。

```c++
class Base {
public:
    Base(int i) {}
    Base(double d, int i) {}
    Base(float f, int i, const char *c) {}
    // ...
};

class Derived : public Base
{
    using Base::Base;
    // ...
    virtual void ExtraInterface() {}
};
```

C++11 标准中继承构造函数被设计为跟派生类中的各种类默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。

不过继承构造函数只会初始化基类中成员变量，对于派生类中的成员变量，则无能为力。

基类构造函数的参数会有默认值，对于继承构造函数来讲，参数的默认值时不会被继承的。事实上，默认值会导致基类产生多个构造函数的版本，这些函数版本都会被派生类继承。

```c++
class Base {
    Base(int a=3, double d=2.4) {}
};

class Derived : public Base {
    using Base::Base;
};
```

事实上，Derived 可能从 Base 中继承来的候选继承构造函数有如下：

```c++
Base(int = 3, double = 2.4);  // 这是使用两个参数的情况
Base(int = 3);  // 这是减掉一个参数的情况
Base(const Base &);  // 这是默认的复制构造函数
Base();  // 这个不使用参数的情况
// Derived 中的构造函数将会包括以下一些：
Derived(int, double);  // 这是一个继承构造函数
Derived(int);  // 这是减少掉一个参数的继承构造函数
Derived(const Derived &);  // 这是复制构造函数, 不是继承来的
Derived();  // 这是不包含参数的默认构造函数
```

如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。如果一旦使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了。

### 五、委派构造函数

通过委派其他构造函数，多构造函数的类编写将更加容易。原则上，编译器不允许在构造函数中调用构造函数。C++11 中的委派构造函数是**在构造函数的初始化列表**位置进行构造的、委派的。

```c++
class Test {
public:
    Test() { Init(); }
    Test(int i) : Test() { type = i; }
    Test(char e) : Test() { name = e; }
    
private:
    void Init() {}
    int type{1};
    char name{'a'};
};
```

委派构造函数只能在函数体中为 type、name 等成员变量赋初值。这是由于委派构造函数不能有初始化列表造成的，在 C++11 中，**构造函数不能同时“委派”和使用初始化列表**，所以如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中。

```c++
class Test {
public:
    Test() : Test(1, 'a') {}
    Test(int i) : Test(i, 'a') {}
    Test(char e) : Test(1, e) {}
    
private:
    Test(int i, char e) : type(i), name(e) {}
    int type{1};
    char name{'a'};
};
```

