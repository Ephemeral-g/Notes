### 一、预定义宏

| 宏                       | 说明                                                         |
| ------------------------ | :----------------------------------------------------------- |
| **\_\_STDC_HOSTED__**    | 如果编译器的目标系统环境中包含完整的标准C库，那么这个宏的值为1， 否则宏的值为0 |
| **\_\_STDC__**           | C编译器通常用这个宏的值来表示编译器的实现是否和C标准一致， C++11 标准中这个宏是否定义以及定成什么值由编译器来决定 |
| **\_\_STDC_VERSION__**   | C编译器通常用这个宏来表示所支持的C标准的版本，比如1999mmL。C++11 标准中这个宏是否定义以及定成什么值将由编译器来决定 |
| **\_\_STDC_ISO_10646__** | 这个宏通常定义为一个 yyyymmL 格式的整数常量。例如 199712L，用来表示C++编译环境符合某个版本的 ISO/IEC 10646 标准 |

预定义宏对于多目标平台代码的编写通常具有重大意义。

### 二、宏 __cplusplus

有时头文件中有如下的声明：

```c++
#ifdef __cplusplus
extern "C" {
#endif
// 一些代码
#ifdef __cplusplus
}
#endif
```

这种类型的头文件可以被 #include 到 C 文件中进行编译, 也可以被 #include 到 C++ 文件中进行编译，由于 extern "C" 可以抑制 C++ 对函数名、变量名的符号进行名称重整，因此编译出的 C 目标文件和 C++ 目标文件中的变量、函数名称等符号都是相同的，链接器可以可靠的对两种类型的目标文件进行链接，这样该做法成为了 C 与 C++ 混用头文件的典型做法。

C++11 标准中, 宏 **__cplusplus** 被预定义为 201103L

```c++
#if __cplusplus < 201103L
    #error "sholud use C++11 implementation"
#endif
```

使用了预处理指令 #error，这使得不支持 C++11 的代码编译立即报错并终止编译。

### 三、\_\_func__ 预定义标识符

基本功能是**返回所在函数的名字**。C++11 允许其使用在类或者结构体中，返回类或结构体的名称，但不允许将 **\_\_func__** 标识符作为函数参数的默认值。

```c++
typedef struct _TEST {
    _TEST() : name(__func__) {}
    const char *name;
}TEST;

int main() {
    TEST t;
    cout << t.name << endl;  // _TEST
}      

// 下面的操作是不允许的
void Func(string func_name = __func__) {}  // 由于在参数声明时, __func__还未被定义.
```

### 四、_Pragma 操作符

**#pragma** 是一条预处理的指令，是用来向编译器传达语言标准以外的一些信息。

C++11 中，定义了与预处理指令 #pragma 功能相同的操作符 **_Pragma**。格式如下：

```c++
_Pragma(字符串字面量)
```

使用方法跟 sizeof 等操作符一样，将字符串字面量作为参数写在括号内即可。由于 _Pragma 是一个操作符，因此也可以用在宏定义中，而 #pragma 不能在宏中展开。

```c++
_Pragma("once");  // 等价于 #pragma once

#define CONCAT(x)  PRAGMA(concat on #x)
#define PRAGMA(x)  _Pragma(#x)
CONCAT(..\concat.dir)  // _Pragma(concat on "..\concat.dir")
```

### 五、变长参数的宏定义以及 \_\_VA_ARGS__

变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义宏 **\_\_VA_ARGS__** 则可以在宏定义的实现部分替换省略号所代表的字符串。

```c++
#define LOG(...) {\
    fprintf(stderr, "%s: Line %d:\t", __FILE__, __LINE__);\
    fprintf(stderr, __VA_ARGS__);\
    fprintf(stderr, "\n");\    
}
```

